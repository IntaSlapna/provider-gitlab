// Package generate generates method sets for Go types.
package generate

import (
	"bytes"
	"go/parser"
	"go/token"
	"go/types"
	"io/ioutil"
	"sort"

	"github.com/dave/jennifer/jen"
	"github.com/negz/angryjet/internal/match"
	"github.com/pkg/errors"
	"golang.org/x/tools/go/packages"
)

// HeaderGenerated is added to all files generated by angryjet.
// See https://github.com/golang/go/issues/13560#issuecomment-288457920.
const HeaderGenerated = "Code generated by https://github.com/negz/angryjet. DO NOT EDIT."

type options struct {
	Matches       match.Object
	ImportAliases map[string]string
	Headers       []string
}

// A WriteOption configures method generation behaviour.
type WriteOption func(o *options)

// WithHeaders specifies strings to be written as comments to the generated
// file, above the package definition. Single line strings use // comments,
// while multiline strings use /**/ comments.
func WithHeaders(h ...string) WriteOption {
	return func(o *options) {
		o.Headers = append(o.Headers, h...)
	}
}

// WithMatcher specifies an Object matcher that is used to filter the Objects
// within the package down to the set that need the generated methods.
func WithMatcher(m match.Object) WriteOption {
	return func(o *options) {
		o.Matches = m
	}
}

// WithImportAliases configures a map of import paths to aliases that will be
// used when generating code. For example if a generated method requires
// "example.org/foo/bar" it may refer to that package as "foobar" by supplying
// map[string]string{"example.org/foo/bar": "foobar"}
func WithImportAliases(ia map[string]string) WriteOption {
	return func(o *options) {
		o.ImportAliases = ia
	}
}

// WriteMethods writes the supplied methods for each object in the supplied
// package to the supplied file. Use WithMatcher to limit the objects for which
// methods will be written. Methods will not be generated if a method with the
// same name is already defined for the object outside of the supplied filename.
// Files will not be written if they would contain no methods.
func WriteMethods(p *packages.Package, ms MethodSet, file string, wo ...WriteOption) error {
	opts := &options{Matches: func(o types.Object) bool { return true }}
	for _, fn := range wo {
		fn(opts)
	}

	f := jen.NewFile(p.Name)
	for path, alias := range opts.ImportAliases {
		f.ImportAlias(path, alias)
	}
	for _, hc := range opts.Headers {
		if hc != "" {
			f.HeaderComment(hc)
		}
	}
	f.HeaderComment(HeaderGenerated)

	for _, n := range p.Types.Scope().Names() {
		o := p.Types.Scope().Lookup(n)
		if !opts.Matches(o) {
			continue
		}
		ms.Write(f, o, HasMethodOutside(p.Fset, file))
	}

	b := &bytes.Buffer{}
	if err := f.Render(b); err != nil {
		return errors.Wrap(err, "cannot render Go file")
	}

	if ProducedNothing(b.Bytes()) {
		return nil
	}

	return errors.Wrap(ioutil.WriteFile(file, b.Bytes(), 0644), "cannot write Go file")

}

// A NewMethod is a function that adds a method on the supplied object in the
// supplied file.
type NewMethod func(f *jen.File, o types.Object)

// A MethodSet is a map of method names to the NewMethod functions that produce
// them.
type MethodSet map[string]NewMethod

// A MethodFilter is a function that determines whether a method should be
// written for the supplied object. It returns true if the method should be
// filtered.
type MethodFilter func(o types.Object, methodName string) bool

// HasMethodOutside returns a MethodFilter that returns true if the supplied
// object has a method with the supplied name that is not defined in the
// supplied filename. The object's filename is determined using the supplied
// FileSet.
func HasMethodOutside(fs *token.FileSet, filename string) MethodFilter {
	return func(o types.Object, name string) bool {
		s := types.NewMethodSet(types.NewPointer(o.Type()))
		for i := 0; i < s.Len(); i++ {
			mo := s.At(i).Obj()
			if mo.Name() != name {
				continue
			}
			if fs.Position(mo.Pos()).Filename != filename {
				return true
			}
		}
		return false
	}
}

// Write the MethodSet for the supplied Object to the supplied file. Methods
// are filtered by the supplied MethodFilter.
func (m MethodSet) Write(f *jen.File, o types.Object, mf MethodFilter) {
	names := make([]string, 0, len(m))
	for name := range m {
		names = append(names, name)
	}
	sort.Strings(names)

	for _, name := range names {
		if mf(o, name) {
			continue
		}
		m[name](f, o)
	}
}

// ProducedNothing returns true if the supplied data is either not a valid Go
// source file, or a valid Go file that contains no top level objects or
// declarations.
func ProducedNothing(data []byte) bool {
	f, err := parser.ParseFile(token.NewFileSet(), "f.go", data, 0)
	if err != nil {
		return true
	}
	return len(f.Decls)+len(f.Scope.Objects) == 0
}
